#!/usr/bin/perl
#
# ***** BEGIN LICENSE BLOCK *****
# Zimbra Collaboration Suite Server
# Copyright (C) 2018 Synacor, Inc.
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software Foundation,
# version 2 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program.
# If not, see <https://www.gnu.org/licenses/>.
# ***** END LICENSE BLOCK *****

=pod
=head1 This utility is used to check orphan headers for given account, if founds any missing blobs, restore it

#Usage
# su - zimbra
# zmrestoreblob -a|account {name@domain|id}
# zmrestoreblob -a test1@zcs-dev.test OR zmrestoreblob -a test1
# where -a is to specify which mailbox account to check.

=cut

use strict;
use warnings;    #or else.
use lib "/opt/zimbra/common/lib/perl5";
use Data::Dumper;
use File::Basename;
use File::Copy;
use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
use Getopt::Long;


my $opt_help;
my $opt_account;
GetOptions(
    "help|h" => \$opt_help,
    "account|a=s" => \$opt_account
);

if (defined($opt_help) || !defined($opt_account)) {
    usage();
}

sub usage {
    print <<EOF;
Usage:
zmrestoreblob -a|account  email-account
    -a|account  - Check orphan headers for given account, if founds any missing blobs, restore it
    -h|help     - Display this help message.
EOF
    exit(0);
}

my $email = $opt_account;

#get zimbraid for a given email account
my $zimbra_id = `zmprov ga $email zimbraid 2>&1`;
if( $zimbra_id =~ /ERROR:/g ) {
    print("[] INFO: $zimbra_id \n");
    exit(1);
}

my @fields = split /:\s+/, $zimbra_id;
$zimbra_id = $fields[1];

#get mailboxId for a given email account
my $mailbox_id = `zmprov gmi $email | grep mailboxId`;
@fields = split /:\s+/, $mailbox_id;
$mailbox_id = $fields[1];

#clean the values...
$zimbra_id =~ s/[\r\n]//g;
$mailbox_id =~ s/[\r\n]//g;

my $backup_dir = "/opt/zimbra/backup/sessions";
my $latest_backup_path = get_latest_backup_dir($backup_dir.'/full-*');

#if no backup exist on server
if (!defined($latest_backup_path)) {
    print("[] INFO: No backup exist on server...\n");
    exit(1);
}

my $first_three = substr($zimbra_id, 0,3);
my $next_three = substr($zimbra_id, 3,3);

$backup_dir =  $latest_backup_path . "/accounts/$first_three/$next_three/$zimbra_id/blobs";

#execute zmblobchk command for a given mailbox.
my $zmblobchk_output = `zmblobchk -m $mailbox_id start`;

# check if there are any orphaned headers.
my $orphaned_header_check = ( $zmblobchk_output =~ /blob not found/g );

chop($zmblobchk_output);

if ($orphaned_header_check) {

    # find the missing blob entries
    my @matches = ( $zmblobchk_output =~ /(\/opt\/zimbra\/store.*\.msg)/gm );

    for my $matched_blob (@matches) {

        my ( $filename, $dirs, $suffix ) = fileparse($matched_blob);
        my $blob_fname = basename($filename);
        my $org_blob_part = get_file_part($filename);

        my @backup_zip_files = glob( $backup_dir . '/*' );
        my $msg_match_flag = 0;
        foreach my $zip_file (@backup_zip_files) {
            # Read a Zip file
            my $backup_file = '';
            my $backup_blob_part = '';
            my $zip = Archive::Zip->new();
            $zip->read($zip_file) == AZ_OK or die 'read error';
            my @members = $zip->membersMatching('.*\.msg1');
            foreach my $member (@members) {
                $backup_file = $member->fileName();
                $backup_blob_part = get_file_part(fileparse($backup_file));

                # if blob exists in backup, restore it in the origin blob path and display appropriate message.
                if($org_blob_part eq $backup_blob_part) {
                    print "[] INFO: Restoring $matched_blob from Backup\n";
                    $member->extractToFileNamed("$matched_blob");
                    $msg_match_flag = 1;
                    last;
                }
            }
        }
        if($msg_match_flag == 0) {
            print "[] INFO: File $matched_blob not found in backup \n";
        }
    }
}
else {
    print "[] INFO: No Orphaned Headers Found\n";
}


sub get_file_part {
    my ($filename) = @_;
    if($filename =~ /.*?(\d+\-\d+\.msg)/gm) {
        return $1;
    }
}

sub get_latest_backup_dir {
    my ($backup_path) = @_;
    my $latest_backup_dir = ( sort {-M $a <=> -M $b} glob($backup_path) )[0];
    return $latest_backup_dir;
}